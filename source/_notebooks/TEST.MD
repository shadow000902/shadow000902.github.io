# 数据不一致问题处理

读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现缓存`Redis`和数据库`MySQL`间的数据一致性问题。

不管是先写`MySQL`数据库，再删除`Redis`缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。
举一个例子：

1. 如果删除了缓存`Redis`，还没有来得及写库`MySQL`，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。
2. 如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。
   因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。

## 解决方案

### 方案一：延时双删策略

在写库前后都进行`redis.del(key)`操作，并且设定合理的超时时间。
伪代码如下：

```java
public void write(String key,Object data){
    redis.delKey(key);
    db.updateData(data);
    Thread.sleep(500);
    redis.delKey(key);
}
```

需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。
当然这种策略还要考虑`redis`和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。
**设置缓存过期时间**：
从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。
**弊端**：
结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。

### 方案二：异步更新缓存(基于订阅`binlog`的同步机制)

技术整体思路：
`MySQL` `binlog`增量订阅消费+消息队列+增量数据更新到`Redis`。

1. `读Redis`：热数据基本都在`Redis`；
2. `写MySQL`：增删改都是操作`MySQL`；
3. `更新Redis数据`：`MySQL`的数据操作`binlog`，来更新到`Redis`。

**`Redis`更新**

1. 数据操作主要分为两大块：
   * 一个是全量(将全部数据一次写入到`Redis`)
   * 一个是增量（实时更新）
   这里说的是增量,指的是`mysql`的`update`、`insert`、`delete`变更数据。
2. 读取`binlog`后分析 ，利用消息队列,推送更新各台的redis缓存数据。

这样一旦`MySQL`中产生了新的写入、更新、删除等操作，就可以把`binlog`相关的消息推送至`Redis`，`Redis`再根据`binlog`中的记录，对`Redis`进行更新。
其实这种机制，很类似`MySQL`的**主从备份机制**，因为`MySQL`的主备也是通过`binlog`来实现的数据一致性。
这里可以结合使用`canal`(阿里的一款开源框架)，通过该框架可以对`MySQL`的`binlog`进行订阅，而`canal`正是模仿了`MySQL`的`slave`数据库的备份请求，使得`Redis`的数据更新达到了相同的效果。
当然，这里的消息推送工具你也可以采用别的第三方：`kafka`、`rabbitMQ`等来实现推送更新`Redis`。
